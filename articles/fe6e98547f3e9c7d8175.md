---
title: "TCP・UDPサーバを作ってみた"
emoji: "🐈"
type: "tech"
topics: ["TCP", "UDP"]
published: false
---

## 前提

自分はプログラマー初心者です。
TCP・UDP の仕組みについては言及しません。
具体的には、チェックサム、輻輳制御、フロー制御等については言及しません。
TCP はコネクション志向で、UDP はコネクションレスと聞いていたので、肌身で感じるために実装しました。

## 概要　

ゆるふわな感じでサーバを作ってどのように通信しているか確認します。

nc(netcat)を使えばサーバもクライアントも用意できるので通信自体は簡単にできますが、tcpサーバも作ってみたかったので、サーバの方は雰囲気で実際に実装してみました。

## 内容

Go で TCP サーバ及び UDP サーバをつくって通信の確認をします

### TCPサーバの実装

適当に Go で TCP サーバを作ります

```go
package main

import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"
)

var dead = 10 * time.Second

func main() {
	if err := run(); err != nil {
		fmt.Printf("error: %v\n", err)
	}
}

func run() error {
	termCh := make(chan os.Signal, 1)
	signal.Notify(termCh, syscall.SIGKILL, syscall.SIGINT)
	errCh := make(chan error, 1)

	addr := &net.TCPAddr{
		IP:   net.ParseIP("127.0.0.1"),
		Port: 8000,
	}
	ln, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return err
	}

	log.Println("Starting tcp server...")

	go func() {
		for {
			ctx := context.Background()
			conn, err := ln.Accept()
			if err != nil {
				errCh <- err
			}
			go func() {
				err = handle(ctx, conn)
				if !(errors.Is(err, os.ErrDeadlineExceeded) || errors.Is(err, io.EOF)) {
					errCh <- err
				}
				fmt.Println("connection is disconnected ")
			}()
		}
	}()

	select {
	case <-termCh:
		return errors.New("terminated by signal")
	case err = <-errCh:
		return err
	}
}

func handle(ctx context.Context, conn net.Conn) error {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	go func() {
		<-ctx.Done()
		conn.Close()
	}()

	err := conn.SetDeadline(time.Now().Add(dead))
	if err != nil {
		return err
	}
	defer conn.Close()

	r := bufio.NewReader(conn)
	for {
		t, err := r.ReadString('\n')
		if err != nil {
			return err
		}

		log.Printf("Receiving data: %v from %s", strings.TrimSuffix(t, "\n"), conn.RemoteAddr().String())
		log.Printf("Sending data..")
		conn.Write([]byte(fmt.Sprintf("received msg: %s\n", strings.TrimSuffix(t, "\n"))))
		log.Printf("Complete Sending data..")
	}
}
```

タイムアウトを10にして通信を確認してみます。


nc(netcat)コマンドでリクエストを送ってみます。

`nc 127.0.0.1 8000`

`hello` と `world` を送ってみます。

```plain
> hello
< received msg: hello
> world
< received msg: world
```

しっかりサーバから応答がきています。

そのままタイムアウトして、WireSharkでもみてみます。

![tcp](https://storage.googleapis.com/zenn-user-upload/yv96g7b9tjksnogrctfuwtwp8q7j)


23~25で3wayハンドシェイクをしているのが確認できます。その後、よくわかりませんが、TCP window updateしてそこからデータのやり取りを始めています。

データの送受信の部分では、 `[ACK]` -> `[PSH,ACK]` の順で通信をし、`[PSH,ACK]` で TCP payloadを送っているのが変わりました。ここらへんはフーンくらいで。

最後にコネクションをCloseをしているのを確認できました。


### シンプルなUDPサーバの実装


```go
package main

import (
	"errors"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

var mux sync.RWMutex
var buf = make([]byte, 5)

func run() error {
	termCh := make(chan os.Signal, 1)
	signal.Notify(termCh, syscall.SIGKILL, syscall.SIGINT)
	errCh := make(chan error, 1)

	udpAddr := &net.UDPAddr{
		IP:   net.ParseIP("127.0.0.1"),
		Port: 6000,
	}
	ln, err := net.ListenUDP("udp", udpAddr)
	if err != nil {
		return err
	}
	defer ln.Close()

	log.Println("Starting udp server...")

	go func() {
		for {
			err = handle(ln)
			if err != nil {
				errCh <- err
			}
		}
	}()

	select {
	case <-termCh:
		return errors.New("terminated by signal")
	case err = <-errCh:
		return err
	}
}

func handle(ln *net.UDPConn) error {
	mux.Lock()
	defer mux.Unlock()
	n, addr, err := ln.ReadFromUDP(buf)
	if err != nil {
		return err
	}

	log.Printf("Receiving data: %s from %s", string(buf[:n]), addr.String())
	log.Printf("Sending data..")
	ln.WriteTo([]byte(fmt.Sprintf("received msg: %v\n", string(buf))), addr)
	log.Printf("Complete Sending data..")
	return nil
}
```

バッファは 5byte しか許していません。なのでそれ以上が送られてきても切り捨て御免です。:sheep:

また、バッファ(`buf`)を使いまわしていますが、メモリを逐一確保したくないくらいの意図で、特に強い意味はありません。

TCP との大きな違いは以下の部分です。

`ln.WriteTo([]byte(fmt.Sprintf("received msg: %v\n", string(buf))), addr)`

ここで `n, addr, err := ln.ReadFromUDP(buf)` からきたアドレス宛のソケットに対して書き込んでいます。コネクションレスなのでトランスポート層ではポート番号を保持しないので、アプリケーション側でよしなにやる必要があるのでしょうかね。

それでは、nc(netcat)コマンドで通信をしてみます。

`nc -u 127.0.0.1 6000`

UDP で通信するので `-u` オプションをつけています。

`hello world` と打ってみます

```plain
hello world
```

```plain
received msg: hello
```

`hello`と返ってきました。きっちり 5byte 分だけ返ってきました。

WireShark で通信の確認をしてみます。

![ws](https://storage.googleapis.com/zenn-user-upload/z3dpyngimp79du0comh52jeajf6a)

クライアントがリクエストを投げてサーバが応答するだけです。TCPの概念である`ACK` や `FIN` といった概念がなく、非常にシンプルですね。
![ws](https://storage.googleapis.com/zenn-user-upload/9i0u44hwq3qectkhwp6h85pb970e)

クライアントのリクエストを見てみると Data 的には 12byte 分(`hello world`)しっかり送っています。

## 終わりに

シンプルなTCPサーバとUDPサーバを実装して、WireShark で通信を確認しました。

UDPはシンプルな通信ですが、TCPは信頼のある通信のために色々と複雑なことをしていると実感できました。
クライアント側で、コネクションプーリングなどをして親切な通信をする大切さが1ミリだけ理解できました。

## 参考にしたもの

* <https://speakerdeck.com/fujiwara3/kamakura-dot-go-number-5>
* <http://ganmacs.hatenablog.com/entry/2017/05/14/233104>
